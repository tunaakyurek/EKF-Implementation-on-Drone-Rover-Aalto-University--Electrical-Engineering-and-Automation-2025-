function animate_rover_xy(true_pose, est_pose, val, isDuration, smoothed_pose, sensor_data)
% ANIMATE_ROVER_XY  Simple XY animation with heading arrows and sensor measurements
% true_pose: [N x 3] [x y theta]
% est_pose:  [N x 3] [x y theta]
% val: if isDuration==true -> target duration in seconds, else -> speed factor
% isDuration (optional): boolean, default false
% smoothed_pose: [N x 3] [x y theta] (optional) - smoothed EKF estimates
% sensor_data: struct (optional) with fields:
%   .gps_pos: [N x 2] GPS position measurements
%   .gps_vel: [N x 2] GPS velocity measurements  
%   .yaw: [N x 1] magnetometer yaw measurements
%   .available: [N x 4] sensor availability flags [GPS_pos, GPS_vel, Mag, IMU]
%
% ANIMATION CONTEXT (RoboMaster S1):
% - true_pose is generated by rover_dynamics driven by u_true = [a_bx; a_by; omega]
%   (accel-level open-loop commands; lateral accel acts as steering). No built-in
%   controller is used in this animation path.
% - est_pose is the EKF output after prediction+updates using synthesized sensor
%   measurements (wheel encoders, GPS position, magnetometer, IMU).

if nargin < 3 || isempty(val), val = 1.0; end
if nargin < 4 || isempty(isDuration), isDuration = false; end
if nargin < 5 || isempty(smoothed_pose), smoothed_pose = []; end
if nargin < 6 || isempty(sensor_data), sensor_data = []; end
N = size(true_pose,1);

figure('Name','Rover XY Animation');
axis equal; grid on; hold on;
xlabel('X [m]'); ylabel('Y [m]');

hTrue = plot(NaN,NaN,'k-','LineWidth',1.5);
hEst  = plot(NaN,NaN,'r--','LineWidth',1.2);
if ~isempty(smoothed_pose)
    hSmooth = plot(NaN,NaN,'g-','LineWidth',1.0);
    qSmooth = quiver(0,0,0,0, 'g', 'LineWidth', 1.0, 'MaxHeadSize', 1.5);
end

% Sensor measurement visualization
if ~isempty(sensor_data)
    % GPS position measurements
    gps_available = sensor_data.available(:,1) == 1;
    if any(gps_available)
        hGPS = plot(sensor_data.gps_pos(gps_available,1), sensor_data.gps_pos(gps_available,2), 'g.', 'MarkerSize', 8, 'DisplayName', 'GPS measurements');
    end
    
    % Magnetometer measurements (shown as small arrows at current position)
    mag_available = sensor_data.available(:,3) == 1;
    
    % Create legend
    if ~isempty(smoothed_pose)
        legend('True path','EKF path','Smoothed path','True heading','EKF heading','Smoothed heading','GPS measurements');
    else
        legend('True path','EKF path','True heading','EKF heading','GPS measurements');
    end
else
    if ~isempty(smoothed_pose)
        legend('True path','EKF path','Smoothed path','True heading','EKF heading','Smoothed heading');
    else
        legend('True path','EKF path','True heading','EKF heading');
    end
end

qTrue = quiver(0,0,0,0, 'k', 'LineWidth', 1.5, 'MaxHeadSize', 2);
qEst  = quiver(0,0,0,0, 'r', 'LineWidth', 1.2, 'MaxHeadSize', 2);

trail_true = nan(N,2);
trail_est  = nan(N,2);
if ~isempty(smoothed_pose)
    trail_smooth = nan(N,2);
end

if isDuration
    startT = tic;
    frame_dt = val / N; % seconds per frame to meet target duration
end

for k = 1:N
    xt = true_pose(k,1); yt = true_pose(k,2); tht = true_pose(k,3);
    xe = est_pose(k,1);  ye = est_pose(k,2);  the = est_pose(k,3);

    trail_true(k,:) = [xt yt];
    trail_est(k,:)  = [xe ye];
    if ~isempty(smoothed_pose)
        xs = smoothed_pose(k,1); ys = smoothed_pose(k,2); ths = smoothed_pose(k,3);
        trail_smooth(k,:) = [xs ys];
    end

    set(hTrue, 'XData', trail_true(:,1), 'YData', trail_true(:,2));
    set(hEst,  'XData', trail_est(:,1),  'YData', trail_est(:,2));
    if ~isempty(smoothed_pose)
        set(hSmooth, 'XData', trail_smooth(:,1), 'YData', trail_smooth(:,2));
    end

    set(qTrue, 'XData', xt, 'YData', yt, 'UData', cos(tht), 'VData', sin(tht));
    set(qEst,  'XData', xe, 'YData', ye, 'UData', cos(the), 'VData', sin(the));
    if ~isempty(smoothed_pose)
        set(qSmooth, 'XData', xs, 'YData', ys, 'UData', cos(ths), 'VData', sin(ths));
    end

    axis([min(trail_true(:,1))-1 max(trail_true(:,1))+1 min(trail_true(:,2))-1 max(trail_true(:,2))+1]);
    % CRITICAL: Force immediate rendering to eliminate UI lag
    drawnow;  % Use full drawnow instead of limitrate for real-time display
    
    % Speed control or duration pacing
    if isDuration
        next_time = k * frame_dt;
        now = toc(startT);
        pause_dur = next_time - now;
        if pause_dur > 0
            pause(pause_dur);
        end
        % Hard-stop if duration exceeded
        if toc(startT) >= val
            break;
        end
    else
        pause(max(0, 0.01 / val));
    end
end

end


